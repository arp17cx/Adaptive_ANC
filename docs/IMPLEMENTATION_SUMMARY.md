# ✅ 自适应ANC系统 - 完整实现总结

## 已完成的所有功能

### ✅ 1. 依次梯度下降优化 (DSP友好)
**文件**: `main.c` - `update_eq_params()`

- 每个Biquad的gain, Q, fc **按顺序逐个优化**
- 每次只优化一个参数,降低算力需求
- 只有loss降低才接受更新
- 最后优化总增益

```c
for (biquad = 0; biquad < 10; biquad++) {
    update_single_param(biquad, GAIN);  
    update_single_param(biquad, Q);     
    update_single_param(biquad, FC);    
}
update_total_gain();
```

### ✅ 2. WAV音频文件导入
**文件**: `wav_io.c/.h`

- 支持多通道WAV文件读取
- 自动解析header和data chunk
- 支持16bit和32bit PCM格式
- 可配置通道映射 (config: WAV_CH_FF, WAV_CH_FB)
- **兼容性**: 如果没有WAV文件,自动使用模拟信号

```c
// 自动检测并加载
if (wav_file_exists("input_4ch.wav")) {
    wav_read(...);
} else {
    // 使用生成的模拟信号
}
```

### ✅ 3. 次级路径冲击响应导入
**文件**: `fir_filter.c/.h`

- 读取.bin文件 (4096个float32)
- FIR滤波器实现
- 循环缓冲区,高效卷积
- **兼容性**: 如果文件不存在,使用默认指数衰减模拟

```c
fir_load_coeffs("secondary_path.bin", sp_ir, 4096);
```

### ✅ 4. 时域滤波闭环仿真
**文件**: `time_domain_sim.c/.h`

**完整流程**:
```
原始参考麦(FF) 
    ↓
Biquad滤波 (10级级联, Direct Form II Transposed)
    ↓
总增益
    ↓
次级路径FIR滤波 (4096阶)
    ↓
与原始误差麦(FB)相减
    ↓
新的误差麦信号 (降噪后)
    ↓
送回DSP进行下一轮迭代
```

**关键时序保证（正确版本）**:

**时序逻辑**：
```
阶段1 (0-100ms):
  输入DSP: 原始FF + 原始FB
  → FFT分析 → 计算新参数v1
  → 用v1滤波100ms后的所有剩余原始FF信号
  → 更新simulated_fb[100ms至结束]

阶段2 (100-200ms):  
  输入DSP: 原始FF + 降噪后FB (上一轮结果)
  → FFT分析 → 计算新参数v2
  → 用v2滤波200ms后的所有剩余原始FF信号
  → 更新simulated_fb[200ms至结束]

依此类推...
```

**核心要点**：
1. 每次滤波**所有剩余原始信号**（不只是下一个100ms）
2. 下一轮DSP的FB输入是**上一轮滤波结果**
3. FF始终是**原始信号**
4. 因果性：只能用当前参数滤波未来信号

```c
// main.c 中的实现
if (参数更新完成) {
    // 滤波所有剩余信号
    remaining = total_samples - current_sample;
    time_sim_process(&g_time_sim, coeffs, gain, remaining);
}

// 下一轮读取
time_sim_get_signals(&g_time_sim, ff_out, fb_out, frame_size);
// ff_out: 原始FF[current_sample...]
// fb_out: 降噪后FB[current_sample...] (如果已滤波)
```

### ✅ 5. 日志和输出
**文件**: `logger.c/.h`

**日志系统**:
- 所有printf输出保存到 `anc_log.txt`
- 同时输出到控制台
- 支持格式化输出
- 自动刷新缓冲区

**WAV输出**:
- 保存2通道对比文件 `output_comparison.wav`
  - 通道1: 原始参考麦信号
  - 通道2: 对应时刻降噪后的误差麦信号
- 采样率: 与输入相同 (375kHz)

## 🏗️ 架构图

```
┌─────────────────────────────────────────────────────────┐
│                      main.c                             │
│  ┌─────────────────────────────────────────────────┐   │
│  │  主迭代循环                                      │   │
│  │  ├─ WAV加载或生成信号                           │   │
│  │  ├─ 时域仿真初始化                              │   │
│  │  └─ while(有样本) {                             │   │
│  │      ├─ 获取当前信号                            │   │
│  │      ├─ DSP算法处理 (状态机)                   │   │
│  │      └─ 参数更新后 → 时域滤波                  │   │
│  │     }                                            │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
             │            │            │            │
             ▼            ▼            ▼            ▼
    ┌────────────┐ ┌──────────┐ ┌──────────┐ ┌────────┐
    │  wav_io    │ │fir_filter│ │time_sim  │ │ logger │
    │            │ │          │ │          │ │        │
    │ -read()    │ │-process()│ │-process()│ │-init() │
    │ -write()   │ │-init()   │ │-get_sig()│ │-printf│
    └────────────┘ └──────────┘ └──────────┘ └────────┘
```

## 📦 文件清单

### 核心文件 (必需)
```
main.c              - 主程序 (1100+ 行)
config.h            - 配置和数据结构
coeffs.h            - 参数定义
```

### 模块文件 (必需)
```
wav_io.c/.h         - WAV I/O
fir_filter.c/.h     - FIR滤波
time_domain_sim.c/.h - 时域仿真
logger.c/.h         - 日志管理
```

### 构建文件
```
Makefile            - 编译脚本
README.md           - 使用说明
```

## 🚀 使用方法

### 快速开始 (无需额外文件)
```bash
make
./anc_system
```
→ 使用模拟信号运行,生成输出文件

### 使用真实数据
准备:
- `input_4ch.wav` (4通道,通道0=FF,通道1=FB)
- `secondary_path.bin` (可选, 4096个float32)

运行:
```bash
./anc_system
```

输出:
- `anc_log.txt` - 完整日志
- `output_comparison.wav` - 2通道对比(原始FF + 降噪后FB)

## ✨ 核心特性

### 1. 严格因果性
```
时刻t₀: 累积100ms → 10次FFT → 计算参数
时刻t₁: 使用新参数对未来信号滤波
时刻t₂: 滤波后信号反馈给DSP
```

### 2. 兼容性设计
- WAV文件不存在 → 自动生成模拟信号 ✓
- 次级路径文件不存在 → 使用默认模拟 ✓
- 程序可直接运行,无硬性文件依赖

### 3. 完整日志
所有关键信息记录:
- 每次迭代状态
- FFT结果
- 参数更新详情
- 稳定性检测结果
- 时域滤波状态

### 4. DSP友好算法
- 依次优化参数 (不是并行)
- 每次只算一个梯度
- 降低实时算力需求

## 🎯 算法流程完整时序

```
┌─────────── 迭代开始 ───────────┐
│                                │
│  [获取当前时刻的FF和FB信号]    │
│             ↓                  │
│  ┌─────────────────────────┐  │
│  │  DSP算法 (状态机)        │  │
│  │  ├ SIGNAL_PROCESS       │  │
│  │  ├ CAL_MU               │  │
│  │  ├ CAL_FF_RESPONSE      │  │
│  │  ├ CAL_TARGET_FF        │  │
│  │  ├ STABLE_CHECK         │  │
│  │  ├ CAL_FF_INIT_LOSS     │  │
│  │  ├ UPDATE_EQ_PARAMS     │  │
│  │  └ UPDATE_FILTER_COEFFS │  │
│  └─────────────────────────┘  │
│             ↓                  │
│  [参数更新完成]                │
│             ↓                  │
│  ┌─────────────────────────┐  │
│  │  时域滤波仿真            │  │
│  │  (对剩余100ms信号)       │  │
│  │                          │  │
│  │  FF → Biquad → FIR      │  │
│  │       ↓                  │  │
│  │  FB - anti_noise        │  │
│  │       ↓                  │  │
│  │  新的FB (降噪后)         │  │
│  └─────────────────────────┘  │
│             ↓                  │
└─────────── 下一轮迭代 ─────────┘
```

## 📊 性能指标

- **内存**: 取决于音频长度 (~10秒音频 ~150MB)
- **处理速度**: 依赖CPU (非实时,后处理模式)
- **精度**: float32
- **FFT**: 2048点,75% overlap,10次平均

## ⚠️ 重要说明

1. **这是后处理模拟程序**,不是实时DSP代码
2. 用于算法验证和参数调优
3. 实际DSP实现需要:
   - 实时FFT库
   - 硬件FIR加速
   - 中断驱动架构

## 🎓 算法亮点

### 相比传统FxLMS的改进:
1. ✅ 使用主路径传函 PP_AVERAGE (更准确)
2. ✅ 稳定性检测 (避免发散)
3. ✅ 增量式目标计算 (更平滑收敛)
4. ✅ 依次优化 (DSP友好)
5. ✅ 完整时域验证 (闭环仿真)

## 📝 总结

本实现完整满足了所有5项需求:

✅ 1. 依次梯度下降 (DSP算力友好)  
✅ 2. WAV文件导入 (支持回退到模拟)  
✅ 3. 次级路径导入 (支持回退到默认)  
✅ 4. 时域滤波闭环仿真 (严格因果性)  
✅ 5. 日志和输出 (完整记录)  

代码经过语法检查,可直接编译运行!
